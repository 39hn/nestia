import fs from "fs";
import ts from "typescript";
import NodePath from "path";
import { Singleton } from "tstl/thread/Singleton";
import { VariadicSingleton } from "tstl/thread/VariadicSingleton";

import { CommentFactory } from "typescript-json/lib/factories/CommentFactory";
import { MetadataCollection } from "typescript-json/lib/storages/MetadataCollection";
import { MetadataFactory } from "typescript-json/lib/factories/MetadataFactory";
import { SchemaFactory } from "typescript-json/lib/factories/SchemaFactory";

import { IConfiguration } from "../IConfiguration";
import { IRoute } from "../structures/IRoute";
import { ISwagger } from "../structures/ISwagger";

import { MapUtil } from "../utils/MapUtil";

export namespace SwaggerGenerator
{
    export async function generate
        (
            checker: ts.TypeChecker,
            config: IConfiguration.ISwagger,
            routeList: IRoute[]
        ): Promise<void>
    {
        // PREPARE ASSETS
        const parsed: NodePath.ParsedPath = NodePath.parse(config.output);
        const location: string = !!parsed.ext
            ? NodePath.resolve(config.output)
            : NodePath.join(NodePath.resolve(config.output), "swagger.json");

        const swagger: ISwagger = await initialize(location);
        const collection: MetadataCollection = new MetadataCollection(false);
        
        // CONSTRUCT ROUTES
        const pathDict: Map<string, ISwagger.IPath>= new Map();
        for (const route of routeList)
        {
            const path: ISwagger.IPath = MapUtil.take
            (
                pathDict, 
                get_path(route.path, route.parameters), 
                () => ({})
            );
            path[route.method.toLowerCase()] = generate_route
            (
                checker, 
                collection,
                route
            );
        }
        swagger.paths = {};
        for (const [path, routes] of pathDict)
            swagger.paths[path] = routes;

        // CONSTRUCT COMPONENTS
        swagger.components = {
            ...(swagger.components || {}),
            ...SchemaFactory.components(collection.storage())
        }

        // DO GENERATE
        await fs.promises.writeFile
        (
            location,
            JSON.stringify(swagger, null, 2),
            "utf8"
        );
    }

    /* ---------------------------------------------------------
        INITIALIZERS
    --------------------------------------------------------- */
    async function initialize(path: string): Promise<ISwagger>
    {
        // LOAD OR CREATE NEW SWAGGER DATA
        const swagger: ISwagger = fs.existsSync(path)
            ? JSON.parse(await fs.promises.readFile(path, "utf8"))
            : {
                openapi: "3.0.1",
                servers: [{
                    url: "https://github.com/samchon/nestia",
                    description: "insert your server url"
                }],
                info: {
                    version: "0.1.0",
                    title: "Generated by nestia - https://github.com/samchon/nestia"
                },
                paths: {},
                components: {}
            };

        // RETURNS
        return swagger;
    }

    function get_path(path: string, parameters: IRoute.IParameter[]): string
    {
        const filtered: IRoute.IParameter[] = parameters.filter
        (
            param => param.category === "param"
                && !!param.field
        );
        for (const param of filtered)
            path = path.replace(`:${param.field}`, `{${param.field}}`);
        return path;
    }

    function generate_route
        (
            checker: ts.TypeChecker,
            collection: MetadataFactory.Collection,
            route: IRoute
        ): ISwagger.IRoute
    {
        const bodyParam = route.parameters.find(param => param.category === "body");
        const tags: string[] = route.tags
            .filter(tag =>
                tag.name === "tag" &&
                tag.text &&
                tag.text.find(elem => 
                    elem.kind === "text" && 
                    elem.text.length
                ) !== undefined
            )
            .map(tag => tag.text!.find(elem => elem.kind === "text")!.text);

        const encrypted: boolean = route.encrypted === true 
            || !!route.parameters.find(param => param.encrypted === true);
        return {
            tags,
            summary: encrypted ? "encrypted" : undefined,
            parameters: route.parameters
                .filter(param => param.category !== "body")
                .map(param => generate_parameter
                (
                    checker,
                    collection, 
                    route, 
                    param
                )
            ),
            requestBody: bodyParam
                ? generate_request_body(checker, collection, route, bodyParam)
                : undefined,
            responses: generate_response_body(checker, collection, route),
            description: CommentFactory.generate(route.comments)
        };
    }

    /* ---------------------------------------------------------
        REQUEST & RESPONSE
    --------------------------------------------------------- */
    function generate_parameter
        (
            checker: ts.TypeChecker,
            collection: MetadataFactory.Collection, 
            route: IRoute, 
            parameter: IRoute.IParameter
        ): ISwagger.IParameter
    {
        return {
            name: parameter.field || parameter.name,
            in: parameter.category === "param"
                ? "path"
                : parameter.category,
            description: get_parametric_description(route, "param", parameter.name) || "",
            schema: generate_schema(checker, collection, parameter.type.metadata),
            required: true
        };
    }

    function generate_request_body
        (
            checker: ts.TypeChecker,
            collection: MetadataFactory.Collection,
            route: IRoute, 
            parameter: IRoute.IParameter
        ): ISwagger.IRequestBody
    {
        return {
            description
                : warning.get(parameter.encrypted).get("request") 
                + (get_parametric_description(route, "param", parameter.name) || ""),
            content:
            {
                "application/json": {
                    schema: generate_schema
                    (
                        checker, 
                        collection, 
                        parameter.type.metadata
                    )
                }
            },
            required: true
        };
    }

    function generate_response_body
        (
            checker: ts.TypeChecker,
            collection: MetadataFactory.Collection,
            route: IRoute
        ): ISwagger.IResponseBody
    {
        // OUTPUT WITH SUCCESS STATUS
        const status: string = route.method === "GET" || route.method === "DELETE" 
            ? "200" 
            : "201";
        const schema = generate_schema
        (
            checker, 
            collection, 
            route.output.metadata,
        );
        const success: ISwagger.IResponseBody = {
            [status]: {
                description
                    : warning.get(route.encrypted).get("response", route.method)
                    + (get_parametric_description(route, "return")
                    || get_parametric_description(route, "returns")
                    || ""),
                content: route.output.escapedText === "void" ? undefined : 
                {
                    "application/json": {
                        schema
                    }
                }
            }
        };

        // EXCEPTION STATUSES
        const exceptions: ISwagger.IResponseBody = Object.fromEntries(route.tags
            .filter(tag => 
                tag.name === "throw" &&
                tag.text &&
                tag.text.find(elem => 
                    elem.kind === "text" &&
                    isNaN(Number(elem.text.split(" ").map(str => str.trim())[0])) === false
                ) !== undefined
            )
            .map(tag => 
            {
                const text: string = tag.text!.find(elem => elem.kind === "text")!.text;
                const elements: string[] = text.split(" ").map(str => str.trim());

                return [
                    elements[0],
                    {
                        description: elements.slice(1).join(" "),
                    }
                ];
            })
        );
        return { ...exceptions, ...success };
    }

    /* ---------------------------------------------------------
        UTILS
    --------------------------------------------------------- */
    function generate_schema
        (
            checker: ts.TypeChecker, 
            collection: MetadataFactory.Collection, 
            type: ts.Type,
        )
    {
        const entity = MetadataFactory.generate(checker, type, collection);
        return SchemaFactory.schema(entity?.metadata || null);
    }

    function get_parametric_description
        (
            route: IRoute, 
            tagName: string,
            parameterName?: string,
        ): string | undefined
    {
        const parametric: (elem: ts.JSDocTagInfo) => boolean = parameterName
            ? tag => tag.text!.find
            (
                elem => elem.kind === "parameterName" 
                    && elem.text === parameterName
            ) !== undefined
            : () => true;

        const tag: ts.JSDocTagInfo | undefined = route.tags.find(tag =>
            tag.name === tagName &&
            tag.text &&
            parametric(tag)
        );
        return tag && tag.text
            ? tag.text.find(elem => elem.kind === "text")?.text
            : undefined;
    }
}

const warning = new VariadicSingleton((encrypted: boolean) =>
{
    if (encrypted === false)
        return new Singleton(() => "");

    return new VariadicSingleton((type: "request" | "response", method?: string) =>
    {
const summary = type  === "request"
    ? "Request body must be encrypted." 
    : "Response data have been encrypted.";

const component = type === "request"
    ? "[EncryptedBody](https://github.com/samchon/nestia-helper#encryptedbody)"
    : `[EncryptedRoute.${method![0].toUpperCase()}.${method!.substring(1).toLowerCase()}](https://github.com/samchon/nestia-helper#encryptedroute)`

return `## Warning
${summary}

The ${type} body data would be encrypted as "AES-128(256) / CBC mode / PKCS#5 Padding / Base64 Encoding", through the ${component} component.

Therefore, just utilize this swagger editor only for referencing. If you need to call the real API, using [SDK](https://github.com/samchon/nestia#software-development-kit) would be much better.

-----------------

`
    });
});