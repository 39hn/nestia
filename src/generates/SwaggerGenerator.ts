import fs from "fs";
import ts from "typescript";
import NodePath from "path";
import { MetadataFactory } from "typescript-json/lib/factories/MetadataFactory";
import { SchemaFactory } from "typescript-json/lib/factories/SchemaFactory";

import { IConfiguration } from "../IConfiguration";
import { IRoute } from "../structures/IRoute";
import { ISwagger } from "../structures/ISwagger";

import { MapUtil } from "../utils/MapUtil";

export namespace SwaggerGenerator
{
    export async function generate
        (
            checker: ts.TypeChecker,
            config: IConfiguration.ISwagger,
            routeList: IRoute[]
        ): Promise<void>
    {
        const parsed: NodePath.ParsedPath = NodePath.parse(config.output);
        const location: string = !!parsed.ext
            ? NodePath.resolve(config.output)
            : NodePath.join(NodePath.resolve(config.output), "swagger.json");

        const swagger: ISwagger = await initialize(location);
        const collection: MetadataFactory.Collection = new MetadataFactory.Collection(false);
        const pathDict: Map<string, ISwagger.IPath>= new Map();

        for (const route of routeList)
        {
            const path: ISwagger.IPath = MapUtil.take
            (
                pathDict, 
                get_path(route.path, route.parameters), 
                () => ({})
            );
            path[route.method.toLowerCase()] = generate_route
            (
                checker, 
                collection, 
                route
            );
        }

        swagger.paths = {};
        for (const [path, routes] of pathDict)
            swagger.paths[path] = routes;
        swagger.components = {
            ...SchemaFactory.components(collection.storage())
        };
        swagger.nestia = "Generated by Nestia - https://github.com/samchon/nestia";

        await fs.promises.writeFile
        (
            location,
            JSON.stringify(swagger, null, 2),
            "utf8"
        );
    }

    async function initialize(path: string): Promise<ISwagger>
    {
        // LOAD OR CREATE NEW SWAGGER DATA
        const swagger: ISwagger = fs.existsSync(path)
            ? JSON.parse(await fs.promises.readFile(path, "utf8"))
            : {
                openapi: "3.0",
                nestia: "",
                paths: {},
                components: {}
            };

        // RETURNS
        return swagger;
    }

    function get_path(path: string, parameters: IRoute.IParameter[]): string
    {
        const filtered: IRoute.IParameter[] = parameters.filter
        (
            param => param.category === "param"
                && !!param.field
        );
        for (const param of filtered)
            path = path.replace(`:${param.field}`, `{${param.field}}`);
        return path;
    }

    function generate_route
        (
            checker: ts.TypeChecker,
            collection: MetadataFactory.Collection,
            route: IRoute
        ): ISwagger.IRoute
    {
        const bodyParam = route.parameters.find(param => param.category === "body");

        return {
            tags: [],
            parameters: route.parameters
                .filter(param => param.category !== "body")
                .map(param => generate_parameter
                (
                    checker,
                    collection, 
                    route, 
                    param
                )
            ),
            requestBody: bodyParam
                ? generate_request_body(checker, collection, route, bodyParam)
                : undefined,
            responses: generate_response_body(checker, collection, route)
        };
    }

    function generate_parameter
        (
            checker: ts.TypeChecker,
            collection: MetadataFactory.Collection, 
            route: IRoute, 
            parameter: IRoute.IParameter
        ): ISwagger.IParameter
    {
        return {
            name: parameter.name,
            in: parameter.category === "param"
                ? "path"
                : parameter.category,
            description: get_parametric_description
            (
                route.comments, 
                "parameterName", 
                parameter.name
            ),
            schema: generate_schema(checker, collection, parameter.type.metadata),
            required: true
        };
    }

    function generate_request_body
        (
            checker: ts.TypeChecker,
            collection: MetadataFactory.Collection,
            route: IRoute, 
            parameter: IRoute.IParameter
        ): ISwagger.IRequestBody
    {
        return {
            description: get_parametric_description
            (
                route.comments, 
                "parameterName", 
                parameter.name
            ),
            content:
            {
                "application/json": {
                    schema: generate_schema(checker, collection, route.output.metadata)
                }
            },
            required: true
        };
    }

    function generate_response_body
        (
            checker: ts.TypeChecker,
            collection: MetadataFactory.Collection,
            route: IRoute
        ): ISwagger.IResponseBody
    {
        const status: string = route.method === "GET" || route.method === "DELETE" 
            ? "200" 
            : "201";
        const schema = generate_schema(checker, collection, route.output.metadata);
            
        return {
            [status]: {
                description
                    : get_parametric_description(route.comments, "return")
                    || get_parametric_description(route.comments, "returns"),
                content: route.output.escapedText === "void" ? undefined : 
                {
                    "application/json": {
                        schema
                    }
                }
            }
        }
    }

    function get_parametric_description(comments: ts.SymbolDisplayPart[], kind: string, text?: string)
    {
        const index = comments.findIndex(c => 
            c.kind === kind &&
            (c.text === text || !text)
        );
        return index !== -1
            ? comments[index + 2]?.text
            : undefined;
    }

    function generate_schema
        (
            checker: ts.TypeChecker, 
            collection: MetadataFactory.Collection, 
            type: ts.Type
        )
    {
        const entity = MetadataFactory.generate(checker, type, collection);
        return SchemaFactory.schema(entity?.metadata || null);
    }
}